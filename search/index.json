[{"content":"c/c++排序算法有关笔记。\n排序算法介绍 排序算法（sorting algorithm）用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理。\n排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则。\n评价维度 运行效率：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要。 就地性：顾名思义，原地排序通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。 稳定性：稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变。 自适应性：自适应排序能够利用输入数据已有的顺序信息来减少计算量，达到更优的时间效率。自适应排序算法的最佳时间复杂度通常优于平均时间复杂度。 是否基于比较 具体排序算法 选择排序 开启一个循环，每轮从未排序区间选择最小/最大的元素，将其放到已排序区间的末尾。\n流程 初始状态下，所有元素未排序，即未排序（索引）区间为 [0, n - 1] 。 选取区间 [0, n - 1] 中的最小元素，将其与索引 0 处的元素交换。完成后，数组前 1 个元素已排序。 选取区间 [1, n - 1] 中的最小元素，将其与索引 1 处的元素交换。完成后，数组前 2 个元素已排序。 以此类推。经过 n - 1 轮选择与交换后，数组前 n - 1 个元素已排序。 仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成。 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* 选择排序 */ void selectionSort(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int n = nums.size(); // 外循环：未排序区间为 [i, n-1] for (int i = 0; i \u0026lt; n - 1; i++) { // 内循环：找到未排序区间内的最小元素 int k = i; for (int j = i + 1; j \u0026lt; n; j++) { if (nums[j] \u0026lt; nums[k]) k = j; // 记录最小元素的索引 } // 将该最小元素与未排序区间的首个元素交换 swap(nums[i], nums[k]); } } 特性 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$ 稳定性：非稳定排序 冒泡排序 通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序。\n流程 设数组的长度为 n\n首先，对 n 个元素执行“冒泡”，将数组的最大元素交换至正确位置。 接下来，对剩余 n - 1 个元素执行“冒泡”，将第二大元素交换至正确位置。 以此类推，经过 n - 1 轮“冒泡”后，前 n - 1 大的元素都被交换至正确位置。 仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。 代码实现（标志优化） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* 冒泡排序（标志优化）*/ void bubbleSortWithFlag(vector\u0026lt;int\u0026gt; \u0026amp;nums) { // 外循环：未排序区间为 [0, i] for (int i = nums.size() - 1; i \u0026gt; 0; i--) { bool flag = false; // 初始化标志位 // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端 for (int j = 0; j \u0026lt; i; j++) { if (nums[j] \u0026gt; nums[j + 1]) { // 交换 nums[j] 与 nums[j + 1] // 这里使用了 std::swap() 函数 swap(nums[j], nums[j + 1]); flag = true; // 记录交换元素 } } if (!flag) break; // 此轮“冒泡”未交换任何元素，直接跳出 } } 特性 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$ 稳定性：稳定排序 插入排序 它的工作原理与手动整理一副牌的过程非常相似。\n流程 初始状态下，数组的第 1 个元素已完成排序。 选取数组的第 2 个元素作为 base ，将其插入到正确位置后，数组的前 2 个元素已排序。 选取第 3 个元素作为 base ，将其插入到正确位置后，数组的前 3 个元素已排序。 以此类推，在最后一轮中，选取最后一个元素作为 base ，将其插入到正确位置后，所有元素均已排序。 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 /* 插入排序 */ void insertionSort(vector\u0026lt;int\u0026gt; \u0026amp;nums) { // 外循环：已排序区间为 [0, i-1] for (int i = 1; i \u0026lt; nums.size(); i++) { int base = nums[i], j = i - 1; // 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置 while (j \u0026gt;= 0 \u0026amp;\u0026amp; nums[j] \u0026gt; base) { nums[j + 1] = nums[j]; // 将 nums[j] 向右移动一位 j--; } nums[j + 1] = base; // 将 base 赋值到正确位置 } } 特性 时间复杂度：$O(n^2)$（平均和最坏情况），$O(n)$（最好情况，数组已排序） 空间复杂度：$O(1)$ 稳定性：稳定排序 快速排序 是一种基于分治策略的排序算法，运行高效，应用广泛。\n核心操作（哨兵划分） 选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。\n选取数组最左端元素作为基准数，初始化两个指针 i 和 j 分别指向数组的两端。 设置一个循环，在每轮中使用 i（j）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。 循环执行步骤 2. ，直到 i 和 j 相遇时停止，最后将基准数交换至两个子数组的分界线。 流程 首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组。 然后，对左子数组和右子数组分别递归执行“哨兵划分”。 持续递归，直至子数组长度为 1 时终止，从而完成整个数组的排序。 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* 哨兵划分 */ int partition(vector\u0026lt;int\u0026gt; \u0026amp;nums, int left, int right) { // 以 nums[left] 为基准数 int i = left, j = right; while (i \u0026lt; j) { while (i \u0026lt; j \u0026amp;\u0026amp; nums[j] \u0026gt;= nums[left]) j--; // 从右向左找首个小于基准数的元素 while (i \u0026lt; j \u0026amp;\u0026amp; nums[i] \u0026lt;= nums[left]) i++; // 从左向右找首个大于基准数的元素 swap(nums[i], nums[j]); // 交换这两个元素 } swap(nums[i], nums[left]); // 将基准数交换至两子数组的分界线 return i; // 返回基准数的索引 } /* 快速排序 */ void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;nums, int left, int right) { // 子数组长度为 1 时终止递归 if (left \u0026gt;= right) return; // 哨兵划分 int pivot = partition(nums, left, right); // 递归左子数组、右子数组 quickSort(nums, left, pivot - 1); quickSort(nums, pivot + 1, right); } 特性 时间复杂度：$O(nlogn)$（平均情况），$O(n^2)$（最坏情况，如数组完全倒序） 空间复杂度：$O(logn)$（平均情况，递归调用栈空间），$O(n)$（最坏情况） 稳定性：非稳定排序 优化 基准数优化：快速排序在某些输入下的时间效率可能降低。举一个极端例子，假设输入数组是完全倒序的，由于我们选择最左端元素作为基准数，那么在哨兵划分完成后，基准数被交换至数组最右端，导致左子数组长度为 n - 1、右子数组长度为 0 。如此递归下去，每轮哨兵划分后都有一个子数组的长度为 0 ，分治策略失效，快速排序退化为“冒泡排序”的近似形式。 我们可以在数组中选取三个候选元素（通常为数组的首、尾、中点元素），并将这三个候选元素的中位数作为基准数。这样一来，基准数“既不太小也不太大”的概率将大幅提升。当然，我们还可以选取更多候选元素，以进一步提高算法的稳健性。采用这种方法后，时间复杂度劣化至 O(n^2) 的概率大大降低。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* 选取三个候选元素的中位数 */ int medianThree(vector\u0026lt;int\u0026gt; \u0026amp;nums, int left, int mid, int right) { int l = nums[left], m = nums[mid], r = nums[right]; if ((l \u0026lt;= m \u0026amp;\u0026amp; m \u0026lt;= r) || (r \u0026lt;= m \u0026amp;\u0026amp; m \u0026lt;= l)) return mid; // m 在 l 和 r 之间 if ((m \u0026lt;= l \u0026amp;\u0026amp; l \u0026lt;= r) || (r \u0026lt;= l \u0026amp;\u0026amp; l \u0026lt;= m)) return left; // l 在 m 和 r 之间 return right; } /* 哨兵划分（三数取中值） */ int partition(vector\u0026lt;int\u0026gt; \u0026amp;nums, int left, int right) { // 选取三个候选元素的中位数 int med = medianThree(nums, left, (left + right) / 2, right); // 将中位数交换至数组最左端 swap(nums[left], nums[med]); // 以 nums[left] 为基准数 int i = left, j = right; while (i \u0026lt; j) { while (i \u0026lt; j \u0026amp;\u0026amp; nums[j] \u0026gt;= nums[left]) j--; // 从右向左找首个小于基准数的元素 while (i \u0026lt; j \u0026amp;\u0026amp; nums[i] \u0026lt;= nums[left]) i++; // 从左向右找首个大于基准数的元素 swap(nums[i], nums[j]); // 交换这两个元素 } swap(nums[i], nums[left]); // 将基准数交换至两子数组的分界线 return i; // 返回基准数的索引 } 尾递归优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* 快速排序（尾递归优化） */ void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;nums, int left, int right) { // 子数组长度为 1 时终止 while (left \u0026lt; right) { // 哨兵划分操作 int pivot = partition(nums, left, right); // 对两个子数组中较短的那个执行快速排序 if (pivot - left \u0026lt; right - pivot) { quickSort(nums, left, pivot - 1); // 递归排序左子数组 left = pivot + 1; // 剩余未排序区间为 [pivot + 1, right] } else { quickSort(nums, pivot + 1, right); // 递归排序右子数组 right = pivot - 1; // 剩余未排序区间为 [left, pivot - 1] } } } 归并排序 是一种基于分治策略的排序算法，包含“划分”和“合并”阶段。\n可以参考讲解视频理解学习。\n流程 划分阶段：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。 计算数组中点 mid ，递归划分左子数组（区间 [left, mid] ）和右子数组（区间 [mid + 1, right] ）。 递归执行上一步，直至子数组区间长度为 1 时终止。 合并阶段：当子数组长度为 1 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* 合并左子数组和右子数组 */ void merge(vector\u0026lt;int\u0026gt; \u0026amp;nums, int left, int mid, int right) { // 左子数组区间为 [left, mid], 右子数组区间为 [mid+1, right] // 创建一个临时数组 tmp ，用于存放合并后的结果 vector\u0026lt;int\u0026gt; tmp(right - left + 1); // 初始化左子数组和右子数组的起始索引 int i = left, j = mid + 1, k = 0; // 当左右子数组都还有元素时，进行比较并将较小的元素复制到临时数组中 while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= right) { if (nums[i] \u0026lt;= nums[j]) tmp[k++] = nums[i++]; else tmp[k++] = nums[j++]; } // 将左子数组和右子数组的剩余元素复制到临时数组中 while (i \u0026lt;= mid) { tmp[k++] = nums[i++]; } while (j \u0026lt;= right) { tmp[k++] = nums[j++]; } // 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间 for (k = 0; k \u0026lt; tmp.size(); k++) { nums[left + k] = tmp[k]; } } /* 归并排序 */ void mergeSort(vector\u0026lt;int\u0026gt; \u0026amp;nums, int left, int right) { // 终止条件 if (left \u0026gt;= right) return; // 当子数组长度为 1 时终止递归 // 划分阶段 int mid = left + (right - left) / 2; // 计算中点 mergeSort(nums, left, mid); // 递归左子数组 mergeSort(nums, mid + 1, right); // 递归右子数组 // 合并阶段 merge(nums, left, mid, right); } 特性 时间复杂度：$O(nlogn)$ 空间复杂度：$O(n)$（需要额外的临时数组用于合并） 稳定性：稳定排序 应用 链表排序（因为链表只能线性访问），此外对于stl里的std::list容器有成员函数sort可调用（参见菜鸟教程c++），可减少工作量。\n计数排序 通过统计元素数量来实现排序，通常应用于整数数组。（适用于数量大但范围小的场景）\n特性 时间复杂度：$O(n + k)$（n为数组长度，k为数据范围） 空间复杂度：$O(k)$（需要额外空间存储计数数组） 稳定性：稳定排序 基数排序 核心思想与计数排序一致，也通过统计个数来实现排序。在此基础上，基数排序利用数字各位之间的递进关系，依次对每一位进行排序，从而得到最终的排序结果。（不断比较并按各个位数上数字的大小排序）\n流程 以学号数据为例，假设数字的最低位是第 1 位，最高位是第 8 位。\n初始化位数 k = 1 。 对学号的第 k 位执行“计数排序”。完成后，数据会根据第 k 位从小到大排序。 将 k 增加 1 ，然后返回步骤 2. 继续迭代，直到所有位都排序完成后结束。 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* 获取元素 num 的第 k 位，其中 exp = 10^(k-1) */ int digit(int num, int exp) { // 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算 return (num / exp) % 10; } /* 计数排序（根据 nums 第 k 位排序） */ void countingSortDigit(vector\u0026lt;int\u0026gt; \u0026amp;nums, int exp) { // 十进制的位范围为 0~9 ，因此需要长度为 10 的桶数组 vector\u0026lt;int\u0026gt; counter(10, 0); int n = nums.size(); // 统计 0~9 各数字的出现次数 for (int i = 0; i \u0026lt; n; i++) { int d = digit(nums[i], exp); // 获取 nums[i] 第 k 位，记为 d counter[d]++; // 统计数字 d 的出现次数 } // 求前缀和，将“出现个数”转换为“数组索引” for (int i = 1; i \u0026lt; 10; i++) { counter[i] += counter[i - 1]; } // 倒序遍历，根据桶内统计结果，将各元素填入 res vector\u0026lt;int\u0026gt; res(n, 0); for (int i = n - 1; i \u0026gt;= 0; i--) { int d = digit(nums[i], exp); int j = counter[d] - 1; // 获取 d 在数组中的索引 j res[j] = nums[i]; // 将当前元素填入索引 j counter[d]--; // 将 d 的数量减 1 } // 使用结果覆盖原数组 nums for (int i = 0; i \u0026lt; n; i++) nums[i] = res[i]; } /* 基数排序 */ void radixSort(vector\u0026lt;int\u0026gt; \u0026amp;nums) { // 获取数组的最大元素，用于判断最大位数 int m = *max_element(nums.begin(), nums.end()); // 按照从低位到高位的顺序遍历 for (int exp = 1; exp \u0026lt;= m; exp *= 10) // 对数组元素的第 k 位执行计数排序 // k = 1 -\u0026gt; exp = 1 // k = 2 -\u0026gt; exp = 10 // 即 exp = 10^(k-1) countingSortDigit(nums, exp); } 为什么从最低位开始排序？ 在连续的排序轮次中，后一轮排序会覆盖前一轮排序的结果。从最低位开始排序可以保证在处理更高位时，相同高位数字的元素之间的相对顺序是基于低位已经排好序的结果，从而保证最终排序的正确性。\n特性 时间复杂度：$O(d(n + b))$，其中 $d$ 是数字的最大位数，$n$ 是数组长度，$b$ 是基数（例如十进制 $b = 10$） 空间复杂度：$O(n + b)$，需要额外的空间用于计数数组和临时存储结果 稳定性：稳定排序 桶排序 可以看作计数排序的延伸，是分治策略的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并。\n流程 考虑一个长度为 $n$ 的数组，其元素是范围 $[0, 1)$ 内的浮点数。\n初始化 $k$ 个桶，将 $n$ 个元素分配到 $k$ 个桶中。 对每个桶分别执行排序（这里采用编程语言的内置排序函数）。 按照桶从小到大的顺序合并结果。 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* 桶排序 */ void bucketSort(vector\u0026lt;float\u0026gt; \u0026amp;nums) { // 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素 int k = nums.size() / 2; vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt; buckets(k); // 1. 将数组元素分配到各个桶中 for (float num : nums) { // 输入数据范围为 [0, 1)，使用 num * k 映射到索引范围 [0, k-1] int i = num * k; // 将 num 添加进桶 bucket_idx buckets[i].push_back(num); } // 2. 对各个桶执行排序 for (vector\u0026lt;float\u0026gt; \u0026amp;bucket : buckets) { // 使用内置排序函数，也可以替换成其他排序算法 sort(bucket.begin(), bucket.end()); } // 3. 遍历桶合并结果 int i = 0; for (vector\u0026lt;float\u0026gt; \u0026amp;bucket : buckets) { for (float num : bucket) { nums[i++] = num; } } } 特性 时间复杂度：如果数据均匀分布，时间复杂度为 $O(n + k \\times (n/k \\log(n/k)))$，化简后为 $O(n + n \\log(n/k))$，当 $k$ 接近 $n$ 时，时间复杂度接近 $O(n)$；如果数据分布不均匀，时间复杂度可能退化为 $O(n^2)$ 空间复杂度：$O(n + k)$，需要额外的空间存储桶以及桶内数据 稳定性：桶排序是否稳定取决于排序桶内元素的算法是否稳定，如果桶内使用的是稳定排序算法，则桶排序是稳定的 堆排序 堆排序是利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\n可以参考视频理解学习。\n流程 建堆：将初始待排序序列 $R[1..n]$ 构建成大顶堆（或小顶堆），此堆为初始的无序区。 调整堆：将堆顶元素 $R[1]$ 与最后一个元素 $R[n]$ 交换，此时得到新的无序区 $R[1..n-1]$ 和新的有序区 $R[n]$，且满足 $R[1..n-1].keys \\leq R[n].key$。 重复调整：由于交换后新的堆顶 $R[1]$ 可能违反堆的性质，因此需要对当前无序区 $R[1..n-1]$ 调整为新堆，然后再次将 $R[1]$ 与无序区最后一个元素交换，得到新的无序区 $R[1..n-2]$ 和新的有序区 $R[n-1..n]$。不断重复此过程直到有序区的元素个数为 $n-1$，则整个排序过程完成。 代码实现（以大顶堆为例） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // 调整堆，将以 i 为根节点的子树调整为大顶堆 void heapify(vector\u0026lt;int\u0026gt;\u0026amp; nums, int n, int i) { int largest = i; // 初始化最大元素为根节点 int left = 2 * i + 1; // 左子节点索引 int right = 2 * i + 2; // 右子节点索引 // 如果左子节点比根节点大 if (left \u0026lt; n \u0026amp;\u0026amp; nums[left] \u0026gt; nums[largest]) largest = left; // 如果右子节点比最大元素还大 if (right \u0026lt; n \u0026amp;\u0026amp; nums[right] \u0026gt; nums[largest]) largest = right; // 如果最大元素不是根节点 if (largest != i) { swap(nums[i], nums[largest]); // 递归地调整被交换的子树 heapify(nums, n, largest); } } // 堆排序函数 void heapSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); // 建堆（从最后一个非叶子节点开始调整） for (int i = n / 2 - 1; i \u0026gt;= 0; i--) heapify(nums, n, i); // 一个一个地从堆顶取出元素 for (int i = n - 1; i \u0026gt; 0; i--) { // 将堆顶元素移到数组末尾 swap(nums[0], nums[i]); // 调用调整堆函数，将剩余的元素重新调整为大顶堆 heapify(nums, i, 0); } } 特性 时间复杂度：$O(n \\log n)$，建堆的时间复杂度为 $O(n)$，调整堆的时间复杂度为 $O(\\log n)$，总共需要调整 $n-1$ 次，所以总的时间复杂度为 $O(n \\log n)$ 空间复杂度：$O(1)$，只需要常数级别的额外空间 稳定性：非稳定排序 ","date":"2025-04-19T00:00:00Z","image":"https://tu-molo.github.io/p/c/c-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/px_hu_491376273ce34cd4.png","permalink":"https://tu-molo.github.io/p/c/c-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","title":"C/C++排序算法"},{"content":"c/c++二分查找算法有关笔记。\n二分查找 二分法 定义 二分查找（binary search），用于在一个有序数组中高效地查找某一个元素。相较于顺序查找的$O(n)$时间复杂度，二分查找能将时间复杂度降低至$O(\\log n)$，极大提升了查找效率。\n过程（升序为例） 初始区间设定：设定初始查找区间为数组的整个范围，即左边界left为数组起始位置（索引为 0），右边界right为数组末尾位置（索引为数组长度减 1）。\n中间元素计算：在每一轮循环中，计算当前区间的中间位置mid，通常通过公式mid = left + (right - left) / 2计算得到，这样可防止left + right时可能出现的溢出情况。\n元素比较与区间更新：\n若中间元素arr[mid]刚好等于所查找的值target，则直接返回mid，查找成功结束。\n若arr[mid]小于target，说明目标值在中间元素右侧，更新左边界left = mid + 1，缩小查找区间为[mid + 1, right]。\n若arr[mid]大于target，说明目标值在中间元素左侧，更新右边界right = mid - 1，缩小查找区间为[left, mid - 1]。\n循环终止条件：当left超过right时，说明在数组中未找到目标值，查找失败，返回特定标识（如 - 1）。\n时间复杂度 二分查找每次将查找区间缩小一半，因此时间复杂度为$O(\\log n)$。这里的$n$是数组的长度。与顺序查找的$O(n)$时间复杂度相比，随着数组规模$n$的增大，二分查找的效率优势愈发明显。例如，当$n = 1024$时，顺序查找平均需要比较 512 次，而二分查找最多只需比较 10 次（因为$2^{10}=1024$）。\n实现 实现方式 1：基本 while 循环实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int binarySearch(int arr[], int n, int target) { int left = 0, right = n - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (arr[mid] == target) { return mid; } else if (arr[mid] \u0026lt; target) { left = mid + 1; } else { right = mid - 1; } } return -1; // 未找到目标值 } 实现方式 2：递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 int binarySearchRecursive(int arr[], int left, int right, int target) { if (left \u0026gt; right) { return -1; // 未找到目标值 } int mid = left + (right - left) / 2; if (arr[mid] == target) { return mid; } else if (arr[mid] \u0026lt; target) { return binarySearchRecursive(arr, mid + 1, right, target); } else { return binarySearchRecursive(arr, left, mid - 1, target); } } 实现方式 3：（红蓝染色法） 红蓝染色法是一种更形象化理解二分的方式。假设数组中的元素可分为 “红”（不满足条件）和 “蓝”（满足条件）两类，且红元素都在蓝元素左侧（或右侧）。通过二分不断调整边界，找到红蓝元素的分界点。以查找满足某条件的最小元素为例：\n1 2 3 4 5 6 7 8 9 10 11 12 int binarySearchByColor(int arr[], int n) { int left = 0, right = n - 1; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (isBlue(arr[mid])) { // isBlue函数判断元素是否满足条件（蓝色） right = mid; } else { left = mid + 1; } } return left; // 返回满足条件的最小索引 } 最大值最小化 广义有序的理解 这里的有序是广义的有序。若一个数组中的左侧或者右侧都满足某一种条件，而另一侧都不满足这种条件，也可看作是一种有序。比如把满足条件看做 1，不满足看做 0，至少对于这个条件的这一维度是有序的。例如，在一个任务分配场景中，数组元素表示不同任务的耗时，我们希望将这些任务分配给若干个机器，使得完成所有任务的最大耗时最小。对于每个可能的最大耗时值x，可以判断能否按照此最大耗时将任务合理分配到机器上，若能分配成功可视为满足条件（标记为 1），否则视为不满足（标记为 0）。在这个条件维度下，存在这样一种广义有序性：若存在一个值x1能满足任务分配条件，那么大于x1的值x2必然也能满足任务分配条件。\n需要满足的条件 答案在一个固定的区间内：例如在上述任务分配例子中，最大耗时的取值范围在任务的最大耗时（所有任务由一台机器完成的情况）和所有任务耗时总和（每个任务由一台单独机器完成的情况）之间。\n判断某个值是否符合条件相对容易：对于给定的一个可能的最大耗时值，编写一个函数来判断能否在该最大耗时限制下完成任务分配，其实现难度相对不大。\n可行解对于区间满足一定的单调性：即如果x是符合条件的，那么有x + 1或者x - 1也符合条件（取决于具体问题是求最大值最小化还是最小值最大化）。在最大值最小化问题中，如果x能满足任务分配条件，那么更大的x + 1必然也能满足，这就保证了在这个区间内使用二分查找的可行性。\nSTL 的二分查找 调用前元素必须有序 在使用 C++ STL 中的二分查找函数前，必须确保数组或容器中的元素是有序的。否则，结果将是未定义的。\n头文件 相关二分查找函数定义在\u0026lt;algorithm\u0026gt;头文件中，使用时需包含此头文件。\nstd::lower_bound std::lower_bound(begin, end, value)函数用于在有序范围[begin, end)内查找第一个大于或等于value的元素的位置。返回一个迭代器指向该位置。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; v = {1, 3, 5, 7, 9}; auto it = std::lower_bound(v.begin(), v.end(), 4); if (it != v.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;第一个大于或等于4的元素是: \u0026#34; \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; std::endl; } return 0; } 上述代码中，std::lower_bound返回指向元素5的迭代器。\nstd::upper_bound std::upper_bound(begin, end, value)函数用于在有序范围[begin, end)内查找第一个大于value的元素的位置。同样返回一个迭代器指向该位置。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; v = {1, 3, 5, 7, 9}; auto it = std::upper_bound(v.begin(), v.end(), 4); if (it != v.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;第一个大于4的元素是: \u0026#34; \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; std::endl; } return 0; } 上述代码中，std::upper_bound也返回指向元素5的迭代器，因为5是第一个大于4的元素。\n","date":"2025-04-16T00:00:00Z","image":"https://tu-molo.github.io/p/c/c-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/erfen_hu_7efafdb01777885e.png","permalink":"https://tu-molo.github.io/p/c/c-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/","title":"C/C++二分查找算法"},{"content":"因为这段时间在准备学校学院里的 acm 竞赛，目前还算熟练掌握的语言就是 c/c++，所以以此开启我对我的学习历程的记录。\n笔记连载内容概述 对hello-算法和oi-wiki两个算法教学网站，以及菜鸟教程上的算法知识的学习与笔记分享。\n基础算法 我会从最基础的算法开始，参考网上大多数的算法教程，按合适的学习顺序，记录我的算法学习笔记。\n连载目标 这个连载的目标是帮助自己建立起扎实的 C/C++ 算法基础。\n在每一篇文章中，我会尽量用自己的语言和理解记录算法知识，同时提供详细的代码示例和解释。\n让我们一起开始吧 从下一篇文章开始，我将正式踏上 C/C++ 算法知识的学习之旅。希望你能和我一起，在这个充满挑战和乐趣的过程中不断探索和成长。\n","date":"2025-04-15T00:00:00Z","image":"https://tu-molo.github.io/p/c/c-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/suanfa_hu_8206e3cc6d3ba773.jpg","permalink":"https://tu-molo.github.io/p/c/c-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","title":"C/C++算法笔记"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://tu-molo.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://tu-molo.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"}]