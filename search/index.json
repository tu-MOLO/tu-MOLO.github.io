[{"content":"c/c++排序算法有关笔记。\n排序算法介绍 排序算法（sorting algorithm）用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理。\n排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则。\n评价维度 运行效率：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要。 就地性：顾名思义，原地排序通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。 稳定性：稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变。 自适应性：自适应排序能够利用输入数据已有的顺序信息来减少计算量，达到更优的时间效率。自适应排序算法的最佳时间复杂度通常优于平均时间复杂度。 是否基于比较 具体排序算法 选择排序 开启一个循环，每轮从未排序区间选择最小/最大的元素，将其放到已排序区间的末尾。\n流程 初始状态下，所有元素未排序，即未排序（索引）区间为 [0, n - 1] 。 选取区间 [0, n - 1] 中的最小元素，将其与索引 0 处的元素交换。完成后，数组前 1 个元素已排序。 选取区间 [1, n - 1] 中的最小元素，将其与索引 1 处的元素交换。完成后，数组前 2 个元素已排序。 以此类推。经过 n - 1 轮选择与交换后，数组前 n - 1 个元素已排序。 仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成。 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* 选择排序 */ void selectionSort(vector\u0026lt;int\u0026gt; \u0026amp;nums) { int n = nums.size(); // 外循环：未排序区间为 [i, n-1] for (int i = 0; i \u0026lt; n - 1; i++) { // 内循环：找到未排序区间内的最小元素 int k = i; for (int j = i + 1; j \u0026lt; n; j++) { if (nums[j] \u0026lt; nums[k]) k = j; // 记录最小元素的索引 } // 将该最小元素与未排序区间的首个元素交换 swap(nums[i], nums[k]); } } 特性 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$ 稳定性：非稳定排序 冒泡排序 通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序。\n流程 设数组的长度为 n\n首先，对 n 个元素执行“冒泡”，将数组的最大元素交换至正确位置。 接下来，对剩余 n - 1 个元素执行“冒泡”，将第二大元素交换至正确位置。 以此类推，经过 n - 1 轮“冒泡”后，前 n - 1 大的元素都被交换至正确位置。 仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。 代码实现（标志优化） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* 冒泡排序（标志优化）*/ void bubbleSortWithFlag(vector\u0026lt;int\u0026gt; \u0026amp;nums) { // 外循环：未排序区间为 [0, i] for (int i = nums.size() - 1; i \u0026gt; 0; i--) { bool flag = false; // 初始化标志位 // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端 for (int j = 0; j \u0026lt; i; j++) { if (nums[j] \u0026gt; nums[j + 1]) { // 交换 nums[j] 与 nums[j + 1] // 这里使用了 std::swap() 函数 swap(nums[j], nums[j + 1]); flag = true; // 记录交换元素 } } if (!flag) break; // 此轮“冒泡”未交换任何元素，直接跳出 } } 特性 时间复杂度：$O(n^2)$ 空间复杂度：$O(1)$ 稳定性：稳定排序 插入排序 它的工作原理与手动整理一副牌的过程非常相似。\n流程 初始状态下，数组的第 1 个元素已完成排序。 选取数组的第 2 个元素作为 base ，将其插入到正确位置后，数组的前 2 个元素已排序。 选取第 3 个元素作为 base ，将其插入到正确位置后，数组的前 3 个元素已排序。 以此类推，在最后一轮中，选取最后一个元素作为 base ，将其插入到正确位置后，所有元素均已排序。 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 /* 插入排序 */ void insertionSort(vector\u0026lt;int\u0026gt; \u0026amp;nums) { // 外循环：已排序区间为 [0, i-1] for (int i = 1; i \u0026lt; nums.size(); i++) { int base = nums[i], j = i - 1; // 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置 while (j \u0026gt;= 0 \u0026amp;\u0026amp; nums[j] \u0026gt; base) { nums[j + 1] = nums[j]; // 将 nums[j] 向右移动一位 j--; } nums[j + 1] = base; // 将 base 赋值到正确位置 } } 特性 时间复杂度：$O(n^2)$（平均和最坏情况），$O(n)$（最好情况，数组已排序） 空间复杂度：$O(1)$ 稳定性：稳定排序 快速排序 是一种基于分治策略的排序算法，运行高效，应用广泛。\n核心操作（哨兵划分） 选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。\n选取数组最左端元素作为基准数，初始化两个指针 i 和 j 分别指向数组的两端。 设置一个循环，在每轮中使用 i（j）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。 循环执行步骤 2. ，直到 i 和 j 相遇时停止，最后将基准数交换至两个子数组的分界线。 流程 首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组。 然后，对左子数组和右子数组分别递归执行“哨兵划分”。 持续递归，直至子数组长度为 1 时终止，从而完成整个数组的排序。 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* 哨兵划分 */ int partition(vector\u0026lt;int\u0026gt; \u0026amp;nums, int left, int right) { // 以 nums[left] 为基准数 int i = left, j = right; while (i \u0026lt; j) { while (i \u0026lt; j \u0026amp;\u0026amp; nums[j] \u0026gt;= nums[left]) j--; // 从右向左找首个小于基准数的元素 while (i \u0026lt; j \u0026amp;\u0026amp; nums[i] \u0026lt;= nums[left]) i++; // 从左向右找首个大于基准数的元素 swap(nums[i], nums[j]); // 交换这两个元素 } swap(nums[i], nums[left]); // 将基准数交换至两子数组的分界线 return i; // 返回基准数的索引 } /* 快速排序 */ void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;nums, int left, int right) { // 子数组长度为 1 时终止递归 if (left \u0026gt;= right) return; // 哨兵划分 int pivot = partition(nums, left, right); // 递归左子数组、右子数组 quickSort(nums, left, pivot - 1); quickSort(nums, pivot + 1, right); } 特性 时间复杂度：$O(nlogn)$（平均情况），$O(n^2)$（最坏情况，如数组完全倒序） 空间复杂度：$O(logn)$（平均情况，递归调用栈空间），$O(n)$（最坏情况） 稳定性：非稳定排序 优化 基准数优化：快速排序在某些输入下的时间效率可能降低。举一个极端例子，假设输入数组是完全倒序的，由于我们选择最左端元素作为基准数，那么在哨兵划分完成后，基准数被交换至数组最右端，导致左子数组长度为 n - 1、右子数组长度为 0 。如此递归下去，每轮哨兵划分后都有一个子数组的长度为 0 ，分治策略失效，快速排序退化为“冒泡排序”的近似形式。 我们可以在数组中选取三个候选元素（通常为数组的首、尾、中点元素），并将这三个候选元素的中位数作为基准数。这样一来，基准数“既不太小也不太大”的概率将大幅提升。当然，我们还可以选取更多候选元素，以进一步提高算法的稳健性。采用这种方法后，时间复杂度劣化至 O(n^2) 的概率大大降低。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* 选取三个候选元素的中位数 */ int medianThree(vector\u0026lt;int\u0026gt; \u0026amp;nums, int left, int mid, int right) { int l = nums[left], m = nums[mid], r = nums[right]; if ((l \u0026lt;= m \u0026amp;\u0026amp; m \u0026lt;= r) || (r \u0026lt;= m \u0026amp;\u0026amp; m \u0026lt;= l)) return mid; // m 在 l 和 r 之间 if ((m \u0026lt;= l \u0026amp;\u0026amp; l \u0026lt;= r) || (r \u0026lt;= l \u0026amp;\u0026amp; l \u0026lt;= m)) return left; // l 在 m 和 r 之间 return right; } /* 哨兵划分（三数取中值） */ int partition(vector\u0026lt;int\u0026gt; \u0026amp;nums, int left, int right) { // 选取三个候选元素的中位数 int med = medianThree(nums, left, (left + right) / 2, right); // 将中位数交换至数组最左端 swap(nums[left], nums[med]); // 以 nums[left] 为基准数 int i = left, j = right; while (i \u0026lt; j) { while (i \u0026lt; j \u0026amp;\u0026amp; nums[j] \u0026gt;= nums[left]) j--; // 从右向左找首个小于基准数的元素 while (i \u0026lt; j \u0026amp;\u0026amp; nums[i] \u0026lt;= nums[left]) i++; // 从左向右找首个大于基准数的元素 swap(nums[i], nums[j]); // 交换这两个元素 } swap(nums[i], nums[left]); // 将基准数交换至两子数组的分界线 return i; // 返回基准数的索引 } 尾递归优化 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* 快速排序（尾递归优化） */ void quickSort(vector\u0026lt;int\u0026gt; \u0026amp;nums, int left, int right) { // 子数组长度为 1 时终止 while (left \u0026lt; right) { // 哨兵划分操作 int pivot = partition(nums, left, right); // 对两个子数组中较短的那个执行快速排序 if (pivot - left \u0026lt; right - pivot) { quickSort(nums, left, pivot - 1); // 递归排序左子数组 left = pivot + 1; // 剩余未排序区间为 [pivot + 1, right] } else { quickSort(nums, pivot + 1, right); // 递归排序右子数组 right = pivot - 1; // 剩余未排序区间为 [left, pivot - 1] } } } 归并排序 是一种基于分治策略的排序算法，包含“划分”和“合并”阶段。\n可以参考讲解视频理解学习。\n流程 划分阶段：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。 计算数组中点 mid ，递归划分左子数组（区间 [left, mid] ）和右子数组（区间 [mid + 1, right] ）。 递归执行上一步，直至子数组区间长度为 1 时终止。 合并阶段：当子数组长度为 1 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* 合并左子数组和右子数组 */ void merge(vector\u0026lt;int\u0026gt; \u0026amp;nums, int left, int mid, int right) { // 左子数组区间为 [left, mid], 右子数组区间为 [mid+1, right] // 创建一个临时数组 tmp ，用于存放合并后的结果 vector\u0026lt;int\u0026gt; tmp(right - left + 1); // 初始化左子数组和右子数组的起始索引 int i = left, j = mid + 1, k = 0; // 当左右子数组都还有元素时，进行比较并将较小的元素复制到临时数组中 while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= right) { if (nums[i] \u0026lt;= nums[j]) tmp[k++] = nums[i++]; else tmp[k++] = nums[j++]; } // 将左子数组和右子数组的剩余元素复制到临时数组中 while (i \u0026lt;= mid) { tmp[k++] = nums[i++]; } while (j \u0026lt;= right) { tmp[k++] = nums[j++]; } // 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间 for (k = 0; k \u0026lt; tmp.size(); k++) { nums[left + k] = tmp[k]; } } /* 归并排序 */ void mergeSort(vector\u0026lt;int\u0026gt; \u0026amp;nums, int left, int right) { // 终止条件 if (left \u0026gt;= right) return; // 当子数组长度为 1 时终止递归 // 划分阶段 int mid = left + (right - left) / 2; // 计算中点 mergeSort(nums, left, mid); // 递归左子数组 mergeSort(nums, mid + 1, right); // 递归右子数组 // 合并阶段 merge(nums, left, mid, right); } 特性 时间复杂度：$O(nlogn)$ 空间复杂度：$O(n)$（需要额外的临时数组用于合并） 稳定性：稳定排序 应用 链表排序（因为链表只能线性访问），此外对于stl里的std::list容器有成员函数sort可调用（参见菜鸟教程c++），可减少工作量。\n计数排序 通过统计元素数量来实现排序，通常应用于整数数组。（适用于数量大但范围小的场景）\n特性 时间复杂度：$O(n + k)$（n为数组长度，k为数据范围） 空间复杂度：$O(k)$（需要额外空间存储计数数组） 稳定性：稳定排序 基数排序 核心思想与计数排序一致，也通过统计个数来实现排序。在此基础上，基数排序利用数字各位之间的递进关系，依次对每一位进行排序，从而得到最终的排序结果。（不断比较并按各个位数上数字的大小排序）\n流程 以学号数据为例，假设数字的最低位是第 1 位，最高位是第 8 位。\n初始化位数 k = 1 。 对学号的第 k 位执行“计数排序”。完成后，数据会根据第 k 位从小到大排序。 将 k 增加 1 ，然后返回步骤 2. 继续迭代，直到所有位都排序完成后结束。 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 /* 获取元素 num 的第 k 位，其中 exp = 10^(k-1) */ int digit(int num, int exp) { // 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算 return (num / exp) % 10; } /* 计数排序（根据 nums 第 k 位排序） */ void countingSortDigit(vector\u0026lt;int\u0026gt; \u0026amp;nums, int exp) { // 十进制的位范围为 0~9 ，因此需要长度为 10 的桶数组 vector\u0026lt;int\u0026gt; counter(10, 0); int n = nums.size(); // 统计 0~9 各数字的出现次数 for (int i = 0; i \u0026lt; n; i++) { int d = digit(nums[i], exp); // 获取 nums[i] 第 k 位，记为 d counter[d]++; // 统计数字 d 的出现次数 } // 求前缀和，将“出现个数”转换为“数组索引” for (int i = 1; i \u0026lt; 10; i++) { counter[i] += counter[i - 1]; } // 倒序遍历，根据桶内统计结果，将各元素填入 res vector\u0026lt;int\u0026gt; res(n, 0); for (int i = n - 1; i \u0026gt;= 0; i--) { int d = digit(nums[i], exp); int j = counter[d] - 1; // 获取 d 在数组中的索引 j res[j] = nums[i]; // 将当前元素填入索引 j counter[d]--; // 将 d 的数量减 1 } // 使用结果覆盖原数组 nums for (int i = 0; i \u0026lt; n; i++) nums[i] = res[i]; } /* 基数排序 */ void radixSort(vector\u0026lt;int\u0026gt; \u0026amp;nums) { // 获取数组的最大元素，用于判断最大位数 int m = *max_element(nums.begin(), nums.end()); // 按照从低位到高位的顺序遍历 for (int exp = 1; exp \u0026lt;= m; exp *= 10) // 对数组元素的第 k 位执行计数排序 // k = 1 -\u0026gt; exp = 1 // k = 2 -\u0026gt; exp = 10 // 即 exp = 10^(k-1) countingSortDigit(nums, exp); } 为什么从最低位开始排序？ 在连续的排序轮次中，后一轮排序会覆盖前一轮排序的结果。从最低位开始排序可以保证在处理更高位时，相同高位数字的元素之间的相对顺序是基于低位已经排好序的结果，从而保证最终排序的正确性。\n特性 时间复杂度：$O(d(n + b))$，其中 $d$ 是数字的最大位数，$n$ 是数组长度，$b$ 是基数（例如十进制 $b = 10$） 空间复杂度：$O(n + b)$，需要额外的空间用于计数数组和临时存储结果 稳定性：稳定排序 桶排序 可以看作计数排序的延伸，是分治策略的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并。\n流程 考虑一个长度为 $n$ 的数组，其元素是范围 $[0, 1)$ 内的浮点数。\n初始化 $k$ 个桶，将 $n$ 个元素分配到 $k$ 个桶中。 对每个桶分别执行排序（这里采用编程语言的内置排序函数）。 按照桶从小到大的顺序合并结果。 代码实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* 桶排序 */ void bucketSort(vector\u0026lt;float\u0026gt; \u0026amp;nums) { // 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素 int k = nums.size() / 2; vector\u0026lt;vector\u0026lt;float\u0026gt;\u0026gt; buckets(k); // 1. 将数组元素分配到各个桶中 for (float num : nums) { // 输入数据范围为 [0, 1)，使用 num * k 映射到索引范围 [0, k-1] int i = num * k; // 将 num 添加进桶 bucket_idx buckets[i].push_back(num); } // 2. 对各个桶执行排序 for (vector\u0026lt;float\u0026gt; \u0026amp;bucket : buckets) { // 使用内置排序函数，也可以替换成其他排序算法 sort(bucket.begin(), bucket.end()); } // 3. 遍历桶合并结果 int i = 0; for (vector\u0026lt;float\u0026gt; \u0026amp;bucket : buckets) { for (float num : bucket) { nums[i++] = num; } } } 特性 时间复杂度：如果数据均匀分布，时间复杂度为 $O(n + k \\times (n/k \\log(n/k)))$，化简后为 $O(n + n \\log(n/k))$，当 $k$ 接近 $n$ 时，时间复杂度接近 $O(n)$；如果数据分布不均匀，时间复杂度可能退化为 $O(n^2)$ 空间复杂度：$O(n + k)$，需要额外的空间存储桶以及桶内数据 稳定性：桶排序是否稳定取决于排序桶内元素的算法是否稳定，如果桶内使用的是稳定排序算法，则桶排序是稳定的 堆排序 堆排序是利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。\n可以参考视频理解学习。\n流程 建堆：将初始待排序序列 $R[1..n]$ 构建成大顶堆（或小顶堆），此堆为初始的无序区。 调整堆：将堆顶元素 $R[1]$ 与最后一个元素 $R[n]$ 交换，此时得到新的无序区 $R[1..n-1]$ 和新的有序区 $R[n]$，且满足 $R[1..n-1].keys \\leq R[n].key$。 重复调整：由于交换后新的堆顶 $R[1]$ 可能违反堆的性质，因此需要对当前无序区 $R[1..n-1]$ 调整为新堆，然后再次将 $R[1]$ 与无序区最后一个元素交换，得到新的无序区 $R[1..n-2]$ 和新的有序区 $R[n-1..n]$。不断重复此过程直到有序区的元素个数为 $n-1$，则整个排序过程完成。 代码实现（以大顶堆为例） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // 调整堆，将以 i 为根节点的子树调整为大顶堆 void heapify(vector\u0026lt;int\u0026gt;\u0026amp; nums, int n, int i) { int largest = i; // 初始化最大元素为根节点 int left = 2 * i + 1; // 左子节点索引 int right = 2 * i + 2; // 右子节点索引 // 如果左子节点比根节点大 if (left \u0026lt; n \u0026amp;\u0026amp; nums[left] \u0026gt; nums[largest]) largest = left; // 如果右子节点比最大元素还大 if (right \u0026lt; n \u0026amp;\u0026amp; nums[right] \u0026gt; nums[largest]) largest = right; // 如果最大元素不是根节点 if (largest != i) { swap(nums[i], nums[largest]); // 递归地调整被交换的子树 heapify(nums, n, largest); } } // 堆排序函数 void heapSort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); // 建堆（从最后一个非叶子节点开始调整） for (int i = n / 2 - 1; i \u0026gt;= 0; i--) heapify(nums, n, i); // 一个一个地从堆顶取出元素 for (int i = n - 1; i \u0026gt; 0; i--) { // 将堆顶元素移到数组末尾 swap(nums[0], nums[i]); // 调用调整堆函数，将剩余的元素重新调整为大顶堆 heapify(nums, i, 0); } } 特性 时间复杂度：$O(n \\log n)$，建堆的时间复杂度为 $O(n)$，调整堆的时间复杂度为 $O(\\log n)$，总共需要调整 $n-1$ 次，所以总的时间复杂度为 $O(n \\log n)$ 空间复杂度：$O(1)$，只需要常数级别的额外空间 稳定性：非稳定排序 ","date":"2025-04-19T00:00:00Z","image":"https://tu-molo.github.io/p/c/c-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/px_hu_491376273ce34cd4.png","permalink":"https://tu-molo.github.io/p/c/c-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","title":"C/C++排序算法"},{"content":"c/c++二分查找算法有关笔记。\n二分查找 二分法 定义 二分查找（binary search），用于在一个有序数组中高效地查找某一个元素。相较于顺序查找的$O(n)$时间复杂度，二分查找能将时间复杂度降低至$O(\\log n)$，极大提升了查找效率。\n过程（升序为例） 初始区间设定：设定初始查找区间为数组的整个范围，即左边界left为数组起始位置（索引为 0），右边界right为数组末尾位置（索引为数组长度减 1）。\n中间元素计算：在每一轮循环中，计算当前区间的中间位置mid，通常通过公式mid = left + (right - left) / 2计算得到，这样可防止left + right时可能出现的溢出情况。\n元素比较与区间更新：\n若中间元素arr[mid]刚好等于所查找的值target，则直接返回mid，查找成功结束。\n若arr[mid]小于target，说明目标值在中间元素右侧，更新左边界left = mid + 1，缩小查找区间为[mid + 1, right]。\n若arr[mid]大于target，说明目标值在中间元素左侧，更新右边界right = mid - 1，缩小查找区间为[left, mid - 1]。\n循环终止条件：当left超过right时，说明在数组中未找到目标值，查找失败，返回特定标识（如 - 1）。\n时间复杂度 二分查找每次将查找区间缩小一半，因此时间复杂度为$O(\\log n)$。这里的$n$是数组的长度。与顺序查找的$O(n)$时间复杂度相比，随着数组规模$n$的增大，二分查找的效率优势愈发明显。例如，当$n = 1024$时，顺序查找平均需要比较 512 次，而二分查找最多只需比较 10 次（因为$2^{10}=1024$）。\n实现 实现方式 1：基本 while 循环实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 int binarySearch(int arr[], int n, int target) { int left = 0, right = n - 1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (arr[mid] == target) { return mid; } else if (arr[mid] \u0026lt; target) { left = mid + 1; } else { right = mid - 1; } } return -1; // 未找到目标值 } 实现方式 2：递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 int binarySearchRecursive(int arr[], int left, int right, int target) { if (left \u0026gt; right) { return -1; // 未找到目标值 } int mid = left + (right - left) / 2; if (arr[mid] == target) { return mid; } else if (arr[mid] \u0026lt; target) { return binarySearchRecursive(arr, mid + 1, right, target); } else { return binarySearchRecursive(arr, left, mid - 1, target); } } 实现方式 3：（红蓝染色法） 红蓝染色法是一种更形象化理解二分的方式。假设数组中的元素可分为 “红”（不满足条件）和 “蓝”（满足条件）两类，且红元素都在蓝元素左侧（或右侧）。通过二分不断调整边界，找到红蓝元素的分界点。以查找满足某条件的最小元素为例：\n1 2 3 4 5 6 7 8 9 10 11 12 int binarySearchByColor(int arr[], int n) { int left = 0, right = n - 1; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (isBlue(arr[mid])) { // isBlue函数判断元素是否满足条件（蓝色） right = mid; } else { left = mid + 1; } } return left; // 返回满足条件的最小索引 } 最大值最小化 广义有序的理解 这里的有序是广义的有序。若一个数组中的左侧或者右侧都满足某一种条件，而另一侧都不满足这种条件，也可看作是一种有序。比如把满足条件看做 1，不满足看做 0，至少对于这个条件的这一维度是有序的。例如，在一个任务分配场景中，数组元素表示不同任务的耗时，我们希望将这些任务分配给若干个机器，使得完成所有任务的最大耗时最小。对于每个可能的最大耗时值x，可以判断能否按照此最大耗时将任务合理分配到机器上，若能分配成功可视为满足条件（标记为 1），否则视为不满足（标记为 0）。在这个条件维度下，存在这样一种广义有序性：若存在一个值x1能满足任务分配条件，那么大于x1的值x2必然也能满足任务分配条件。\n需要满足的条件 答案在一个固定的区间内：例如在上述任务分配例子中，最大耗时的取值范围在任务的最大耗时（所有任务由一台机器完成的情况）和所有任务耗时总和（每个任务由一台单独机器完成的情况）之间。\n判断某个值是否符合条件相对容易：对于给定的一个可能的最大耗时值，编写一个函数来判断能否在该最大耗时限制下完成任务分配，其实现难度相对不大。\n可行解对于区间满足一定的单调性：即如果x是符合条件的，那么有x + 1或者x - 1也符合条件（取决于具体问题是求最大值最小化还是最小值最大化）。在最大值最小化问题中，如果x能满足任务分配条件，那么更大的x + 1必然也能满足，这就保证了在这个区间内使用二分查找的可行性。\nSTL 的二分查找 调用前元素必须有序 在使用 C++ STL 中的二分查找函数前，必须确保数组或容器中的元素是有序的。否则，结果将是未定义的。\n头文件 相关二分查找函数定义在\u0026lt;algorithm\u0026gt;头文件中，使用时需包含此头文件。\nstd::lower_bound std::lower_bound(begin, end, value)函数用于在有序范围[begin, end)内查找第一个大于或等于value的元素的位置。返回一个迭代器指向该位置。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; v = {1, 3, 5, 7, 9}; auto it = std::lower_bound(v.begin(), v.end(), 4); if (it != v.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;第一个大于或等于4的元素是: \u0026#34; \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; std::endl; } return 0; } 上述代码中，std::lower_bound返回指向元素5的迭代器。\nstd::upper_bound std::upper_bound(begin, end, value)函数用于在有序范围[begin, end)内查找第一个大于value的元素的位置。同样返回一个迭代器指向该位置。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #include \u0026lt;vector\u0026gt; int main() { std::vector\u0026lt;int\u0026gt; v = {1, 3, 5, 7, 9}; auto it = std::upper_bound(v.begin(), v.end(), 4); if (it != v.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;第一个大于4的元素是: \u0026#34; \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; std::endl; } return 0; } 上述代码中，std::upper_bound也返回指向元素5的迭代器，因为5是第一个大于4的元素。\n","date":"2025-04-16T00:00:00Z","image":"https://tu-molo.github.io/p/c/c-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/erfen_hu_7efafdb01777885e.png","permalink":"https://tu-molo.github.io/p/c/c-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/","title":"C/C++二分查找算法"},{"content":"因为这段时间在准备学校学院里的 acm 竞赛，目前还算熟练掌握的语言就是 c/c++，所以以此开启我对我的学习历程的记录。\n笔记连载内容概述 对hello-算法和oi-wiki两个算法教学网站，以及菜鸟教程上的算法知识的学习与笔记分享。\n基础算法 我会从最基础的算法开始，参考网上大多数的算法教程，按合适的学习顺序，记录我的算法学习笔记。\n连载目标 这个连载的目标是帮助自己建立起扎实的 C/C++ 算法基础。\n在每一篇文章中，我会尽量用自己的语言和理解记录算法知识，同时提供详细的代码示例和解释。\n让我们一起开始吧 从下一篇文章开始，我将正式踏上 C/C++ 算法知识的学习之旅。希望你能和我一起，在这个充满挑战和乐趣的过程中不断探索和成长。\n","date":"2025-04-15T00:00:00Z","image":"https://tu-molo.github.io/p/c/c-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/suanfa_hu_8206e3cc6d3ba773.jpg","permalink":"https://tu-molo.github.io/p/c/c-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","title":"C/C++算法笔记"}]