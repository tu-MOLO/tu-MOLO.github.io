[{"content":"c/c++二分查找算法有关笔记。\n二分查找 二分法 定义 二分查找（binary search），用于在一个有序数组中高效地查找某一个元素。相较于顺序查找的$O(n)$时间复杂度，二分查找能将时间复杂度降低至$O(\\log n)$，极大提升了查找效率。\n过程（升序为例） 初始区间设定：设定初始查找区间为数组的整个范围，即左边界left为数组起始位置（索引为 0），右边界right为数组末尾位置（索引为数组长度减 1）。\n中间元素计算：在每一轮循环中，计算当前区间的中间位置mid，通常通过公式mid = left + (right - left) / 2计算得到，这样可防止left + right时可能出现的溢出情况。\n元素比较与区间更新：\n若中间元素arr[mid]刚好等于所查找的值target，则直接返回mid，查找成功结束。\n若arr[mid]小于target，说明目标值在中间元素右侧，更新左边界left = mid + 1，缩小查找区间为[mid + 1, right]。\n若arr[mid]大于target，说明目标值在中间元素左侧，更新右边界right = mid - 1，缩小查找区间为[left, mid - 1]。\n循环终止条件：当left超过right时，说明在数组中未找到目标值，查找失败，返回特定标识（如 - 1）。\n时间复杂度 二分查找每次将查找区间缩小一半，因此时间复杂度为$O(\\log n)$。这里的$n$是数组的长度。与顺序查找的$O(n)$时间复杂度相比，随着数组规模$n$的增大，二分查找的效率优势愈发明显。例如，当$n = 1024$时，顺序查找平均需要比较 512 次，而二分查找最多只需比较 10 次（因为$2^{10}=1024$）。\n实现 实现方式 1：基本 while 循环实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int binarySearch(int arr\\[], int n, int target) { \u0026amp;#x20; int left = 0, right = n - 1; \u0026amp;#x20; while (left \u0026lt;= right) { \u0026amp;#x20; int mid = left + (right - left) / 2; \u0026amp;#x20; if (arr\\[mid] == target) { \u0026amp;#x20; return mid; \u0026amp;#x20; } else if (arr\\[mid] \u0026lt; target) { \u0026amp;#x20; left = mid + 1; \u0026amp;#x20; } else { \u0026amp;#x20; right = mid - 1; \u0026amp;#x20; } \u0026amp;#x20; } \u0026amp;#x20; return -1; // 未找到目标值 } 实现方式 2：递归实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int binarySearchRecursive(int arr\\[], int left, int right, int target) { \u0026amp;#x20; if (left \u0026gt; right) { \u0026amp;#x20; return -1; // 未找到目标值 \u0026amp;#x20; } \u0026amp;#x20; int mid = left + (right - left) / 2; \u0026amp;#x20; if (arr\\[mid] == target) { \u0026amp;#x20; return mid; \u0026amp;#x20; } else if (arr\\[mid] \u0026lt; target) { \u0026amp;#x20; return binarySearchRecursive(arr, mid + 1, right, target); \u0026amp;#x20; } else { \u0026amp;#x20; return binarySearchRecursive(arr, left, mid - 1, target); \u0026amp;#x20; } } 实现方式 3：（红蓝染色法） 红蓝染色法是一种更形象化理解二分的方式。假设数组中的元素可分为 “红”（不满足条件）和 “蓝”（满足条件）两类，且红元素都在蓝元素左侧（或右侧）。通过二分不断调整边界，找到红蓝元素的分界点。以查找满足某条件的最小元素为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int binarySearchByColor(int arr\\[], int n) { \u0026amp;#x20; int left = 0, right = n - 1; \u0026amp;#x20; while (left \u0026lt; right) { \u0026amp;#x20; int mid = left + (right - left) / 2; \u0026amp;#x20; if (isBlue(arr\\[mid])) { // isBlue函数判断元素是否满足条件（蓝色） \u0026amp;#x20; right = mid; \u0026amp;#x20; } else { \u0026amp;#x20; left = mid + 1; \u0026amp;#x20; } \u0026amp;#x20; } \u0026amp;#x20; return left; // 返回满足条件的最小索引 } 最大值最小化 广义有序的理解 这里的有序是广义的有序。若一个数组中的左侧或者右侧都满足某一种条件，而另一侧都不满足这种条件，也可看作是一种有序。比如把满足条件看做 1，不满足看做 0，至少对于这个条件的这一维度是有序的。例如，在一个任务分配场景中，数组元素表示不同任务的耗时，我们希望将这些任务分配给若干个机器，使得完成所有任务的最大耗时最小。对于每个可能的最大耗时值x，可以判断能否按照此最大耗时将任务合理分配到机器上，若能分配成功可视为满足条件（标记为 1），否则视为不满足（标记为 0）。在这个条件维度下，存在这样一种广义有序性：若存在一个值x1能满足任务分配条件，那么大于x1的值x2必然也能满足任务分配条件。\n需要满足的条件 答案在一个固定的区间内：例如在上述任务分配例子中，最大耗时的取值范围在任务的最大耗时（所有任务由一台机器完成的情况）和所有任务耗时总和（每个任务由一台单独机器完成的情况）之间。\n判断某个值是否符合条件相对容易：对于给定的一个可能的最大耗时值，编写一个函数来判断能否在该最大耗时限制下完成任务分配，其实现难度相对不大。\n可行解对于区间满足一定的单调性：即如果x是符合条件的，那么有x + 1或者x - 1也符合条件（取决于具体问题是求最大值最小化还是最小值最大化）。在最大值最小化问题中，如果x能满足任务分配条件，那么更大的x + 1必然也能满足，这就保证了在这个区间内使用二分查找的可行性。\nSTL 的二分查找 调用前元素必须有序 在使用 C++ STL 中的二分查找函数前，必须确保数组或容器中的元素是有序的。否则，结果将是未定义的。\n头文件 相关二分查找函数定义在\u0026lt;algorithm\u0026gt;头文件中，使用时需包含此头文件。\nstd::lower_bound std::lower_bound(begin, end, value)函数用于在有序范围[begin, end)内查找第一个大于或等于value的元素的位置。返回一个迭代器指向该位置。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \\#include \\\u0026lt;iostream\u0026gt; \\#include \\\u0026lt;algorithm\u0026gt; \\#include \\\u0026lt;vector\u0026gt; int main() { \u0026amp;#x20; std::vector\\\u0026lt;int\u0026gt; v = {1, 3, 5, 7, 9}; \u0026amp;#x20; auto it = std::lower\\_bound(v.begin(), v.end(), 4); \u0026amp;#x20; if (it != v.end()) { \u0026amp;#x20; std::cout \u0026lt;\u0026lt; \u0026#34;第一个大于或等于4的元素是: \u0026#34; \u0026lt;\u0026lt; \\*it \u0026lt;\u0026lt; std::endl; \u0026amp;#x20; } \u0026amp;#x20; return 0; } 上述代码中，std::lower_bound返回指向元素5的迭代器。\nstd::upper_bound std::upper_bound(begin, end, value)函数用于在有序范围[begin, end)内查找第一个大于value的元素的位置。同样返回一个迭代器指向该位置。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \\#include \\\u0026lt;iostream\u0026gt; \\#include \\\u0026lt;algorithm\u0026gt; \\#include \\\u0026lt;vector\u0026gt; int main() { \u0026amp;#x20; std::vector\\\u0026lt;int\u0026gt; v = {1, 3, 5, 7, 9}; \u0026amp;#x20; auto it = std::upper\\_bound(v.begin(), v.end(), 4); \u0026amp;#x20; if (it != v.end()) { \u0026amp;#x20; std::cout \u0026lt;\u0026lt; \u0026#34;第一个大于4的元素是: \u0026#34; \u0026lt;\u0026lt; \\*it \u0026lt;\u0026lt; std::endl; \u0026amp;#x20; } \u0026amp;#x20; return 0; } 上述代码中，std::upper_bound也返回指向元素5的迭代器，因为5是第一个大于4的元素。\n","date":"2025-04-16T00:00:00Z","image":"https://tu-molo.github.io/erfen.jpg","permalink":"https://tu-molo.github.io/p/c/c-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","title":"C/C++算法笔记"},{"content":"因为这段时间在准备学校学院里的 acm 竞赛，目前还算熟练掌握的语言就是 c/c++，所以以此开启我对我的学习历程的记录。\n笔记连载内容概述 对hello-算法和oi-wiki两个算法教学网站，以及菜鸟教程上的算法知识的学习与笔记分享。\n基础算法 我会从最基础的算法开始，参考网上大多数的算法教程，按合适的学习顺序，记录我的算法学习笔记。\n连载目标 这个连载的目标是帮助自己建立起扎实的 C/C++ 算法基础。\n在每一篇文章中，我会尽量用自己的语言和理解记录算法知识，同时提供详细的代码示例和解释。\n让我们一起开始吧 从下一篇文章开始，我将正式踏上 C/C++ 算法知识的学习之旅。希望你能和我一起，在这个充满挑战和乐趣的过程中不断探索和成长。\n","date":"2025-04-15T00:00:00Z","image":"https://tu-molo.github.io/erfen.jpg","permalink":"https://tu-molo.github.io/p/c/c-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/","title":"C/C++算法笔记"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://tu-molo.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://tu-molo.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"}]